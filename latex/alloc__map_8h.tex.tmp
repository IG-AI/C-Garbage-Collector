\hypertarget{alloc__map_8h}{}\section{alloc\+\_\+map.\+h File Reference}
\label{alloc__map_8h}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}


A module for creating and handling the allocation map. Heavily based on bitmap provided by T. Wrigstad at\+: \href{https://github.com/IOOPM-UU/ioopm16/blob/master/forelasningar/fas1/f12/f12.pdf}{\tt https\+://github.\+com/\+I\+O\+O\+P\+M-\/\+U\+U/ioopm16/blob/master/forelasningar/fas1/f12/f12.\+pdf}.  


{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
Include dependency graph for alloc\+\_\+map.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structalloc__map}{alloc\+\_\+map} \hyperlink{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}{alloc\+\_\+map\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{alloc__map_8h_abd8dc8820178f56815663435082389f4}{alloc\+\_\+map\+\_\+create} (\hyperlink{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}{alloc\+\_\+map\+\_\+t} $\ast$\hyperlink{structalloc__map}{alloc\+\_\+map}, void $\ast$start\+\_\+addr, size\+\_\+t word\+\_\+size, size\+\_\+t block\+\_\+size)
\begin{DoxyCompactList}\small\item\em Creates allocation map. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{alloc__map_8h_a9792318f8d96126bd0c5a010a90adfe3}{alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed} (size\+\_\+t word\+\_\+size, size\+\_\+t block\+\_\+size)
\begin{DoxyCompactList}\small\item\em Gets the size needed for an allocation map. \end{DoxyCompactList}\item 
bool \hyperlink{alloc__map_8h_a8a6cb8cdfd0b0fa6f513208adfdfd037}{alloc\+\_\+map\+\_\+ptr\+\_\+used} (\hyperlink{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}{alloc\+\_\+map\+\_\+t} $\ast$\hyperlink{structalloc__map}{alloc\+\_\+map}, void $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Looks up if a memory address is pointing to the start of an object allocated on the gc-\/heap. \end{DoxyCompactList}\item 
bool \hyperlink{alloc__map_8h_a501dcca977bed95d8ff87806cc8a9952}{alloc\+\_\+map\+\_\+set} (\hyperlink{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}{alloc\+\_\+map\+\_\+t} $\ast$\hyperlink{structalloc__map}{alloc\+\_\+map}, void $\ast$ptr, bool state)
\begin{DoxyCompactList}\small\item\em Flags an address. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A module for creating and handling the allocation map. Heavily based on bitmap provided by T. Wrigstad at\+: \href{https://github.com/IOOPM-UU/ioopm16/blob/master/forelasningar/fas1/f12/f12.pdf}{\tt https\+://github.\+com/\+I\+O\+O\+P\+M-\/\+U\+U/ioopm16/blob/master/forelasningar/fas1/f12/f12.\+pdf}. 

We have discovered that this implementation of allocation map require more memory than what should be needed. Instead of using one bit for each address it need one byte.

\begin{DoxyAuthor}{Author}
Daniel Agstrand 

Henrik Bergendal 

Adam Inersjo 

Maria Lindqvist 

Simon Pellgard 

Robert Rosborg 
\end{DoxyAuthor}


\subsection{Typedef Documentation}
\hypertarget{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}{}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}!alloc\+\_\+map\+\_\+t@{alloc\+\_\+map\+\_\+t}}
\index{alloc\+\_\+map\+\_\+t@{alloc\+\_\+map\+\_\+t}!alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}
\subsubsection[{alloc\+\_\+map\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf alloc\+\_\+map} {\bf alloc\+\_\+map\+\_\+t}}\label{alloc__map_8h_a1dd850d0c221c065db145344bbd56714}
The alloc map is a collection of boolean values each showing if an adress on the heap is at the start of an object. 

\subsection{Function Documentation}
\hypertarget{alloc__map_8h_abd8dc8820178f56815663435082389f4}{}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}!alloc\+\_\+map\+\_\+create@{alloc\+\_\+map\+\_\+create}}
\index{alloc\+\_\+map\+\_\+create@{alloc\+\_\+map\+\_\+create}!alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}
\subsubsection[{alloc\+\_\+map\+\_\+create}]{\setlength{\rightskip}{0pt plus 5cm}void alloc\+\_\+map\+\_\+create (
\begin{DoxyParamCaption}
\item[{{\bf alloc\+\_\+map\+\_\+t} $\ast$}]{alloc\+\_\+map, }
\item[{void $\ast$}]{start\+\_\+addr, }
\item[{size\+\_\+t}]{word\+\_\+size, }
\item[{size\+\_\+t}]{block\+\_\+size}
\end{DoxyParamCaption}
)}\label{alloc__map_8h_abd8dc8820178f56815663435082389f4}


Creates allocation map. 

This function creates an allocation map on the provided pointer.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{structalloc__map}{alloc\+\_\+map}} & the adress where the allocation map is to be created.\\
\hline
{\em start\+\_\+addr} & the starting address for the memory block the allocation map represents. \\
\hline
{\em word\+\_\+size} & the size of the words which the memory block is divided into. \\
\hline
{\em block\+\_\+size} & the size in bytes of the memory block the map is going to represent \\
\hline
\end{DoxyParams}
\hypertarget{alloc__map_8h_a9792318f8d96126bd0c5a010a90adfe3}{}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}!alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed@{alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed}}
\index{alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed@{alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed}!alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}
\subsubsection[{alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t alloc\+\_\+map\+\_\+mem\+\_\+size\+\_\+needed (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{word\+\_\+size, }
\item[{size\+\_\+t}]{block\+\_\+size}
\end{DoxyParamCaption}
)}\label{alloc__map_8h_a9792318f8d96126bd0c5a010a90adfe3}


Gets the size needed for an allocation map. 


\begin{DoxyParams}{Parameters}
{\em word\+\_\+size} & the size of the words which the memory block is divided into.\\
\hline
{\em block\+\_\+size} & the size in bytes of the memory block the map is going to represent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the size in bytes needed to store the allocation map. 
\end{DoxyReturn}
\hypertarget{alloc__map_8h_a8a6cb8cdfd0b0fa6f513208adfdfd037}{}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}!alloc\+\_\+map\+\_\+ptr\+\_\+used@{alloc\+\_\+map\+\_\+ptr\+\_\+used}}
\index{alloc\+\_\+map\+\_\+ptr\+\_\+used@{alloc\+\_\+map\+\_\+ptr\+\_\+used}!alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}
\subsubsection[{alloc\+\_\+map\+\_\+ptr\+\_\+used}]{\setlength{\rightskip}{0pt plus 5cm}bool alloc\+\_\+map\+\_\+ptr\+\_\+used (
\begin{DoxyParamCaption}
\item[{{\bf alloc\+\_\+map\+\_\+t} $\ast$}]{alloc\+\_\+map, }
\item[{void $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\label{alloc__map_8h_a8a6cb8cdfd0b0fa6f513208adfdfd037}


Looks up if a memory address is pointing to the start of an object allocated on the gc-\/heap. 


\begin{DoxyParams}{Parameters}
{\em \hyperlink{structalloc__map}{alloc\+\_\+map}} & pointer to the alloc map. \\
\hline
{\em ptr} & pointer to the adress to look up.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool representing the bit of the supplied ptr. False if {\ttfamily ptr} not in scope of {\ttfamily \hyperlink{structalloc__map}{alloc\+\_\+map}} 
\end{DoxyReturn}
\hypertarget{alloc__map_8h_a501dcca977bed95d8ff87806cc8a9952}{}\index{alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}!alloc\+\_\+map\+\_\+set@{alloc\+\_\+map\+\_\+set}}
\index{alloc\+\_\+map\+\_\+set@{alloc\+\_\+map\+\_\+set}!alloc\+\_\+map.\+h@{alloc\+\_\+map.\+h}}
\subsubsection[{alloc\+\_\+map\+\_\+set}]{\setlength{\rightskip}{0pt plus 5cm}bool alloc\+\_\+map\+\_\+set (
\begin{DoxyParamCaption}
\item[{{\bf alloc\+\_\+map\+\_\+t} $\ast$}]{alloc\+\_\+map, }
\item[{void $\ast$}]{ptr, }
\item[{bool}]{state}
\end{DoxyParamCaption}
)}\label{alloc__map_8h_a501dcca977bed95d8ff87806cc8a9952}


Flags an address. 


\begin{DoxyParams}{Parameters}
{\em \hyperlink{structalloc__map}{alloc\+\_\+map}} & pointer to the alloc map \\
\hline
{\em ptr} & the pointer to set. \\
\hline
{\em state} & the value to set. \\
\hline
\end{DoxyParams}
